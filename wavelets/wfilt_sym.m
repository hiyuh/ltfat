function [h, g, a, info] = wfilt_sym(N)
%WFILT_SYM Symlet filters
%   Usage: [h, g, a, info] = wfilt_sym(N);
%
%   `[h, g, a] = wfilt_sym(N)` generates the "least asymmetric" Daubechies'
%   orthogonal wavelets or "symlets" with *N* vanishing moments and
%   length *2N*.
%   Zeros of the trigonometrical polynomial the filters consist of in the
%   Z-plane are selected alternatingly inside and outside the unit circle.
%
%   Remark: Filters generated by this routine differ slightly from the
%   ones in the reference (table 6.3, figure. 6.4) because of the ambiguity
%   in the algorithm.
%
%   Examples:
%   ---------
%   :::
%     wfiltinfo('sym8');
%
%   References: daub98tenlectures

% Original copyright goes to:
%--------------------------------------------------------
% Copyright (C) 1994, 1995, 1996, by Universidad de Vigo
%
% Uvi_Wave is free software; you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation; either version 2, or (at your option) any
% later version.
%
% Uvi_Wave is distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
% FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
% for more details.
%
% You should have received a copy of the GNU General Public License
% along with Uvi_Wave; see the file COPYING.  If not, write to the Free
% Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
%
%       Author: Jose Martin Garcia
%       e-mail: Uvi_Wave@tsc.uvigo.es
%--------------------------------------------------------

if (N == 1); % Haar filters
	[h, g, a, info] = wfilt_db(1);
	return;
end;

p = tpoly(N);
r = roots(p);
% NOTE: r looks already being sorted by sort(..., 'descend').
% NOTE: r(imag(r) == 0) has reciprocal identity such as,
%       * r(imag(r) == 0) is [rz1, 1 / rz1], or [].
% NOTE: r has conjugate/reciprocal identities such as,
%       * r(imag(r) ~= 0) is [ri1, conj(ri1), ..., 1 / conj(ri1), 1 / ri1], or [].
rz = r(imag(r) == 0); nrz = length(rz);
ri = r(imag(r) ~= 0); nri = length(ri);

log2index = nri / 4 + nrz / 2;
log2nn    = 10; % NOTE: Consider radix of IEEE 754 binary64 and allocation/calculation cost.
index     = 2^log2index;
nn        = 2^log2nn;
phase = zeros(index, nn + 1);
for i = 1:index;
	b = dec2bin(i - 1, log2index);
	for j = 1:(nrz / 2);
		if (b(j) == 0);
			phase(i, :) += atang(rz(j), log2nn);
		else
			phase(i, :) += atang(1 / rz(j), log2nn);
		end;
	end;
	for j = 1:(nri / 4);
		if (b(j + nrz / 2) == 0);
			phase(i, :) += atang(ri(2 * j - 1), log2nn);
		else
			phase(i, :) += atang(1 / ri(2 * j - 1), log2nn);
		end;
	end;
end;

% NOTE: To retain only the non linear part of the phase.
for i = 1:index;
	lpi = linspace(phase(i, 1), phase(i, nn + 1), nn + 1);
	phase(i, :) = phase(i, :) - lpi;
end;

% NOTE: To see which phase is closer to zero we select the one with minimun variance
pe = sum(phase'.^2);
[~, pos] = min(pe);
% FIXME: MATLAB's SYMAUX looks doing artificial offset to pos...
b = dec2bin(pos - 1, log2index);
rc = [];
for i = 1:(nrz / 2);
	if (b(i) == 0);
		rc = [rc, rz(i)];
	else
		rc = [rc, 1 / rz(i)];
	end;
end;
for i = 1:(nri / 4);
	if (b(i + nrz / 2) == 0);
		rc = [rc, ri(2 * i - 1)];
	else
		rc = [rc, 1 / ri(2 * i - 1)];
	end;
end;

%rc = [-ones(1, N), sort(rc,  'ascend')(:)'];
 rc = [-ones(1, N), sort(rc, 'descend')(:)'];
%rc = [sort(rc,  'ascend')(:)', -ones(1, N)];
%rc = [sort(rc, 'descend')(:)', -ones(1, N)];
 c = [1];
for i = 1:length(rc);
	if (imag(rc(i)) == 0);
		c = conv(c, [1, -real(rc(i))]);
	else
		c = conv(c, [1, -2 * real(rc(i)), abs(rc(i))^2]);
	end;
end;
c *= sqrt(2) / sum(c);

% FIXME: ???
%if any(N == [7, 9]) || (N >= 13 && rem(N, 2) == 1);
%	c = fliplr(c);
%end;

g{1} = c;
g{2} = -(-1).^(0:(2 * N - 1)) .* fliplr(g{1});
d = cellfun(@(gEl) - length(gEl) / 2, g);
if (N > 2);
	% Do a filter alignment according to "center of mass"
	d(1) = -find(abs(g{1}) == max(abs(g{1})), 1, 'first') + 1;
	d(2) = -find(abs(g{2}) == max(abs(g{2})), 1, 'first') + 1;
	if (abs(rem(d(1) - d(2), 2)) == 1);
	% Shift d(2) just a bit
	d(2) = d(2) - 1;
	end;
end;

g = cellfun(@(gEl, dEl) struct('h', gEl(:), 'offset', dEl), g, num2cell(d), 'UniformOutput', 0);
h = g; info.istight = 1;
a = [2;2];

%DEC2BINA B = DEC2BIN(D, NB) returns a vector which contains
%         the decimal number D in binary format, with a number of
%         digits equal to BITS. It is an auxiliary function used by
%         SYMLETS.
function b = dec2bin(d, nb)
b = [];
q = d;
while (q > 1);
	b = [rem(q, 2), b];
	q = fix(q / 2);
end;
b = [zeros(1, nb - 1 - length(b)), q, b];

%ATANG PHASE = ATANG(Z, LOG2N) returns the phase contribution of Z
%      Linear terms have been removed. It is an auxiliary
%      function used by SYMLETS.
function phase = atang(z, log2n)
iz = imag(z);
w  = linspace(0, 2 * pi, 2^log2n + 1);
if (iz == 0);
	rz = real(z);
	ph = atan((1 + rz) / (1 - rz) * tan(w / 2));
	rp = 1 - rz;
else
	az = abs(z); paz2 = 1 + az^2; maz2 = 1 - az^2;
	tz = arg(z); actz2 = 2 * az * cos(tz);
	ph = atan(maz2 * sin(w) ./ (paz2 * cos(w) - actz2));
	pp = acos(actz2 / paz2);
	rp = maz2 * sin(pp);
end;
if (rp < 0);
	phase = ph + w;
	pu = pi;
else
	phase = ph - w;
	pu = -pi;
end;
if (iz == 0);
	u = 2^(log2n - 1) + 2; phase(u:end) -= pu;
else
	u0 = pp * 2^(log2n - 1) / pi;
	u1 =            ceil(u0) + 1; phase(u1:end) -= pu;
	u2 = 2^log2n - floor(u0) + 1; phase(u2:end) -= pu;
end;

%TPOLY P = TPOLY(N) returns trigonometric polynomial of degree N.
%      It is an auxiliary function used by SYMLETS.
function p = tpoly(N)
coe = zeros(N, 2 * N - 1);
for i = 0:(N - 1);
	f = [1];
	for j = 1:i;
		f = conv(f, [1, -2, 1]);
	end;
	coe(i + 1, (N - i):(N + i)) = ((-1)^i) * nchoosek(N - 1 + i, i) * f / (2^(2 * i));
end;
for i = 1:(2 * N - 1);
	p(i) = sum(coe(:, i));
end;
